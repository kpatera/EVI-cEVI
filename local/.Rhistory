#' @param lag_max Integer. Restriction of the maximum window size for the rolling window size. The default is set to one month (lag_max=30) to prevent excess volatility of past epidemic waves from affecting the most recent volatility estimates and the ability of EVI to warn for upcoming waves that may be smaller and of lower volatility than previous ones.
#'
#'
#' @examples
#'      \dontrun{
#'         # Epidemic Volatility Index (EVI) Explained:
#' 	       vignette('EVI', package='EVI')
#'
#'	       # For information on how to cite EVI:
#'	       citation('EVI')
#'	    }
#'
#' @importFrom stats sd
#'
#' @export
#'
#' @references
#' Kostoulas, P., Meletis, E., Pateras, K. et al. The epidemic volatility index, a novel early warning tool for identifying new waves in an epidemic. Sci Rep 11, 23775 (2021). \doi{10.1038/s41598-021-02622-3}
deviant=function(new_cases, cum = FALSE, r_a=7, r=0.2, lag_max=30){
start_time = Sys.time()
start_cases=14
lag_1=7
c_1=0.01
w_s =7
if (cum == TRUE) new_cases = c(new_cases[1], diff(new_cases))
#calculate the moving average of new confirmed cases
#cases=mova(new_cases,r_a)
cases=new_cases
roll=rollsd(cases[1:start_cases],lag_1)
ev=evi(roll)
ind=indic(ev,c_1, cases[1:start_cases])
status=status(cases[1:start_cases],r)
#initiate chain for positive predictive value
ppv=rep(NA, length(cases))
#initiate chain for negative predictive value
npv=rep(NA, length(cases))
lag_all=rep(NA, start_cases)
c_all=rep(NA, start_cases)
se_all=rep(NA, start_cases)
sp_all=rep(NA, start_cases)
lag_all[1:start_cases]=lag_1
c_all[1:start_cases]=c_1
for (i in (start_cases+1): length(cases)){
case_t=cases[1:i]
#case_t=cases[max(1,(i-33)):i]
#lag_s=7
lag_s=seq(lag_1,min(lag_max,(length(case_t)-1)), 1)
#lag_s=seq(lag_1,min(length(case_t),50), 1)
c_s=seq(0.01,0.5, 0.01)
#all_j=NA
all_lag=NA
all_cut=NA
all_se=NA
all_sp=NA
for (j in lag_s){
roll_t=rollsd(case_t,j)
ev_t=evi(roll_t)
for (l in c_s){
evicut_t=evifcut(ev_t, case_t, l, r)
new_j=j
new_l=l
new_se=evicut_t$sens
new_sp=evicut_t$spec
all_lag[[length(all_lag) + 1]] <- new_j
all_cut[[length(all_cut) + 1]] <- new_l
all_se[[length(all_se) + 1]] <- new_se
all_sp[[length(all_sp) + 1]] <- new_sp
}
}
sesp=as.data.frame(cbind(all_lag,all_cut,all_se,all_sp))
#Select the row with the right window and cut
index=which.max(sesp$all_se+sesp$all_sp-1)
#index=sesp[which(sesp$all_sp>0.80),]
#index=which.max(index$all_se)
#index=which(sesp$all_se==1 & sesp$all_sp>=0.95),1)
#if (i>40)
#   {index1=sesp[which(sesp$all_sp>0.95),]
#  index=which.max(index1$all_se)
#   }
#else
#{index=which.max(sesp$all_se+sesp$all_sp-1)}
#index=which(sesp$se>=0.6 & sesp$sp>0.9)
print(i)
print(sesp[index,])
#estimate the parameters for the last observed case
lag_n=sesp$all_lag[index]
c_n=sesp$all_cut[index]
roll_n=rollsd(cases[1:i],lag_n)
ev_n=evi(roll_n)
ind_n=indic(ev_n, c_n, case_t)
evicut_n=evifcut(ev_n,case_t, c_n, r)
roll=c(roll,roll_n[i])
ev=c(ev,ev_n[i])
ind=c(ind, ind_n[i])
lag_all=c(lag_all,lag_n)
c_all=c(c_all,c_n)
se_all=c(se_all,all_se[index])
sp_all=c(sp_all,all_sp[index])
ppv[i]=evicut_n$prev*all_se[index]/
(evicut_n$prev*all_se[index]+(1-evicut_n$prev)*(1-all_sp[index]))
npv[i]=(1-evicut_n$prev)*all_sp[index]/
((1-evicut_n$prev)*all_sp[index]+evicut_n$prev*(1-all_se[index]))
}
Days=(1:length(cases))
EVI=ev
Cases=cases
Index=ind
EVI_out=as.data.frame(cbind(Days, EVI, Cases, Index, ppv, npv,
lag_all, c_all, se_all, sp_all))
EVI_output = EVI_out
EVI_output<<-(EVI_output)
end_time = Sys.time()
time_elapsed = end_time - start_time
print(time_elapsed)
return(EVI_output)
}
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan,cum = TRUE)
evifcut
require(EVI)
evifcut
rm(evifcut())
rm(evifcut
)
evifcut
evifcut=function (evi, cases, cut, r)
{
w_s = 7
ratio = 1/(1 + r)
test_p = rep(NA, length(cases))
true_p = rep(NA, length(cases))
for (i in w_s:(length(cases) - w_s)) {
if (evi[i] >= cut && cases[i] > mean(cases[i:(i - 6)])) {
test_p[i] = 1
}
else {
test_p[i] = 0
}
if (mean(cases[(i - (w_s - 1)):i]) <= ratio * mean(cases[(i +
1):(i + w_s)])) {
true_p[i] = 1
}
else {
true_p[i] = 0
}
}
sens = length(which(test_p == 1 & true_p == 1))/length(which(true_p ==
1))
spec = length(which(test_p == 0 & true_p == 0))/length(which(true_p ==
0))
sens[is.nan(sens)] <- 0
spec[is.nan(spec)] <- 0
testsin = length(which(test_p == 1))/(length(cases) - w_s)
prev = length(which(true_p == 1))/(length(cases) - w_s)
evifcut <- list(sens = sens, spec = spec, testsin = testsin,
prev = prev)
return(evifcut)
}
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan,cum = TRUE)
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan[1:120],cum = TRUE)
cbind(tmp_EVI_af$Index,Afghanistan2$Index[1:120])
deviant
status
cbind(tmp_EVI_af$ppv,Afghanistan2$pvs[1:120])
cbind(tmp_EVI_af$c_all,Afghanistan2$c_all[1:120])
cbind(tmp_EVI_af$lag_all,Afghanistan2$lag_all[1:120])
tmp_EVI_af=deviant(new_cases = Afghanistan[1:200],cum = TRUE)
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan[1:400],cum = TRUE)
cbind(tmp_EVI_af$lag_all,Afghanistan2$lag_all[1:120])
evifcut
remove.packages("cEVIplus", lib="~/R/win-library/4.1")
library(EVI)
require(gridExtra)
require(ggplot2)
# source("cEVI/deviant_cEVI.R")
# source("cEVI/evifcut_cEVI.R")
# source("cEVI/indic_cEVI.R")
# source("cEVI/cEVI_fun.R")
# source("cEVI/cEVI_fun.R")
# source("cEVI/evi.graphs.comb.R")
# Load the mot example
# Run cEVI for the first cases of Italy
#tmp_EVI_at=deviant(new_cases = Austria$ncases)
#tmp_cEVI_at=deviant_plus(new_cases = Austria$ncases,lag_max = 40)
# 2 min for Austria 150
# 2 min for Italy 150
#tmp_EVI_ita=deviant(new_cases = Italy$Cases)
#tmp_cEVI_ita=deviant_plus(new_cases = Italy$Cases,lag_max = 40)
library(readr)
Afghanistan2 <- data.frame(read_csv("Afghanistan_2022-03-23_file.csv"))
Colombia2 <- data.frame(read_csv("Colombia_2022-03-23_file.csv"))
India2 <- data.frame(read_csv("India_2022-03-23_file.csv"))
France2 <- data.frame(read_csv("France_2022-03-23_file.csv"))
dim(Afghanistan2)
dim(Colombia2)
dim(India2)
dim(France2)
library(readr)
gs_27522 <- as.data.frame(read_csv("globalcases.csv"))
Afghanistan<-Colombia<-India<-France<-NULL
Afghanistan<-as.vector(t(gs_27522[gs_27522$`Country/Region`=="Afghanistan",][5:dim(gs_27522)[2]]))
Colombia<-as.vector(t(gs_27522[gs_27522$`Country/Region`=="Colombia",][5:dim(gs_27522)[2]]))
India<-as.vector(t(gs_27522[gs_27522$`Country/Region`=="India",][5:dim(gs_27522)[2]]))
France<-as.vector(t(gs_27522[gs_27522$`Country/Region`=="France",][5:dim(gs_27522)[2]][12,]))
### Run EVI cEVI for afghanistan
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan[1:100],cum = TRUE)
deviant
#' This function produces the Epidemic Volatility Index based output data
#'
#' This is the main function of the \code{\link[EVI:EVI-package]{EVI-package}} that you should use to analyze a time series of observed cases per unit of time (ideally per day).
#'
#'
#' For each time point the stored variables are:
#'@return \itemize{
#' \item{Dates: the date for each time point (with origin 01-01-1970).}
#'
#'\item{Days: the serial number for each time point.}
#'
#'\item{EVI: the estimated EVI for each time point.}
#'
#'\item{Cases: the rolling average of the newly observed cases for each time point. A 7-day rolling average is calculated by default (i.e., r_a=7). The user has the option to change this by modifying r_a.}
#'
#'\item{Index: takes values 1 or 0 for the issuance of an early warning or not, respectively.}
#'
#'\item{ppv: the positive predictive value for each time point.}
#'
#'\item{npv: the negative predictive value for each time point.}
#'
#'\item{lag_all: the selected rolling window size for EVI calculation for each time point.}
#'
#'\item{c_all: the selected cut-off for issuing an early warning for each time point.}
#'
#'\item{se_all: the sensitivity (Se) of EVI up to this time point.}
#'
#'\item{sp_all: the specificity (Sp) of EVI up to this time point.}}
#' @param new_cases the time series of the newly observed cases per unit of time (ideally per day).
#' @param cum TRUE or FALSE; TRUE if the time series is recorded as the cumulative number of the reported cases and FALSE (the default) if newly reported cases per unit of time are recorded.
#' @param r_a The window size for the moving average that will be analyzed. If set to 1 the actual observations are analyzed. However, due to the variability of the reported cases between working days and weekends it is recommended that the 7-day moving average is analyzed (i.e. r_a = 7), which is the default for this argument. Users could prefer a longer interval of 14 days or one month (i.e., r_a=14 or 30, respectively).
#' @param r Definition for the minimum difference in the mean number of cases, one week before and after each time point that, if present, should be detected. This is the case definition and the default is 0.2 (with 0 <= r <= 1). A value of r=0.2 means that we have a case when the mean number of the newly observed cases in the next 7 days is at least 20% higher than the mean number of the newly observed cases in the past 7 days.
#' @param lag_max Integer. Restriction of the maximum window size for the rolling window size. The default is set to one month (lag_max=30) to prevent excess volatility of past epidemic waves from affecting the most recent volatility estimates and the ability of EVI to warn for upcoming waves that may be smaller and of lower volatility than previous ones.
#'
#'
#' @examples
#'      \dontrun{
#'         # Epidemic Volatility Index (EVI) Explained:
#' 	       vignette('EVI', package='EVI')
#'
#'	       # For information on how to cite EVI:
#'	       citation('EVI')
#'	    }
#'
#' @importFrom stats sd
#'
#' @export
#'
#' @references
#' Kostoulas, P., Meletis, E., Pateras, K. et al. The epidemic volatility index, a novel early warning tool for identifying new waves in an epidemic. Sci Rep 11, 23775 (2021). \doi{10.1038/s41598-021-02622-3}
deviant=function(new_cases, cum = FALSE, r_a=7, r=0.2, lag_max=30){
start_time = Sys.time()
start_cases = 14
lag_1 = 7
c_1 = 0.01
w_s = 7
if (cum == TRUE)
new_cases = c(new_cases[1], diff(new_cases))
cases = mova(new_cases, r_a)
roll = rollsd(cases[1:start_cases], lag_1)
ev = evi(roll)
ind = indic(ev, c_1, cases[1:start_cases])
status = status(cases[1:start_cases], r)
ppv = rep(NA, length(cases))
npv = rep(NA, length(cases))
lag_all = rep(NA, start_cases)
c_all = rep(NA, start_cases)
se_all = rep(NA, start_cases)
sp_all = rep(NA, start_cases)
lag_all[1:start_cases] = lag_1
c_all[1:start_cases] = c_1
for (i in (start_cases + 1):length(cases)) {
case_t = cases[1:i]
lag_s = seq(lag_1, min(lag_max, (length(case_t) - 1)),
1)
c_s = seq(0.01, 0.5, 0.01)
all_lag = NA
all_cut = NA
all_se = NA
all_sp = NA
for (j in lag_s) {
roll_t = rollsd(case_t, j)
ev_t = evi(roll_t)
for (l in c_s) {
evicut_t = evifcut(ev_t, case_t, l, r)
new_j = j
new_l = l
new_se = evicut_t$sens
new_sp = evicut_t$spec
all_lag[[length(all_lag) + 1]] <- new_j
all_cut[[length(all_cut) + 1]] <- new_l
all_se[[length(all_se) + 1]] <- new_se
all_sp[[length(all_sp) + 1]] <- new_sp
}
}
sesp = as.data.frame(cbind(all_lag, all_cut, all_se,
all_sp))
index = which.max(sesp$all_se + sesp$all_sp - 1)
print(i)
print(sesp[index, ])
lag_n = sesp$all_lag[index]
c_n = sesp$all_cut[index]
roll_n = rollsd(cases[1:i], lag_n)
ev_n = evi(roll_n)
ind_n = indic(ev_n, c_n, case_t)
evicut_n = evifcut(ev_n, case_t, c_n, r)
roll = c(roll, roll_n[i])
ev = c(ev, ev_n[i])
ind = c(ind, ind_n[i])
lag_all = c(lag_all, lag_n)
c_all = c(c_all, c_n)
se_all = c(se_all, all_se[index])
sp_all = c(sp_all, all_sp[index])
ppv[i] = evicut_n$prev * all_se[index]/(evicut_n$prev *
all_se[index] + (1 - evicut_n$prev) * (1 - all_sp[index]))
npv[i] = (1 - evicut_n$prev) * all_sp[index]/((1 - evicut_n$prev) *
all_sp[index] + evicut_n$prev * (1 - all_se[index]))
}
Days = (1:length(cases))
EVI = ev
Cases = cases
Index = ind
EVI_out = as.data.frame(cbind(Days, EVI, Cases, Index, ppv,
npv, lag_all, c_all, se_all, sp_all))
EVI_output = EVI_out
EVI_output <<- (EVI_output)
end_time = Sys.time()
time_elapsed = end_time - start_time
print(time_elapsed)
return(EVI_output)
}
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan[1:100],cum = TRUE)
indic=function (evi, cut, cases)
{
ind = rep(NA, length(evi))
for (i in 3:length(evi)) {
if (evi[i] >= cut && cases[i] > mean(cases[i:(i - min(7,
i))])) {
ind[i] = 1
}
else {
ind[i] = 0
}
}
return(ind)
}
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan[1:100],cum = TRUE)
evifcut=function (evi, cases, cut, r)
{
w_s = 7
ratio = 1/(1 + r)
test_p = rep(NA, length(cases))
true_p = rep(NA, length(cases))
for (i in w_s:(length(cases) - w_s)) {
if (evi[i] >= cut && cases[i] > mean(cases[i:(i - 6)])) {
test_p[i] = 1
}
else {
test_p[i] = 0
}
if (mean(cases[(i - (w_s - 1)):i]) <= ratio * mean(cases[(i +
1):(i + w_s)])) {
true_p[i] = 1
}
else {
true_p[i] = 0
}
}
sens = length(which(test_p == 1 & true_p == 1))/length(which(true_p ==
1))
spec = length(which(test_p == 0 & true_p == 0))/length(which(true_p ==
0))
sens[is.nan(sens)] <- 0
spec[is.nan(spec)] <- 0
testsin = length(which(test_p == 1))/(length(cases) - w_s)
prev = length(which(true_p == 1))/(length(cases) - w_s)
evifcut <- list(sens = sens, spec = spec, testsin = testsin,
prev = prev)
return(evifcut)
}
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan[1:100],cum = TRUE)
#' Standard deviation
#'
#' This function calculates the standard deviation of a vector.
#' @return
#' Returns the standard deviation of a vector.
#'
#' @param x numeric vector
#'
#'
#' @examples
#' x = c(2,2,1,4,9,10,23,10,9,10,14,12,10)
#' medvol(x)
#'
#' @export
#'
#' @references
#' Kostoulas, P., Meletis, E., Pateras, K. et al. The epidemic volatility index, a novel early warning tool for identifying new waves in an epidemic. Sci Rep 11, 23775 (2021). \doi{10.1038/s41598-021-02622-3}
#'
medvol=function(x){
sdx<-sd(x)
return(sdx)
}
#' Moving Average
#'
#' This function calculates the moving average of a time series.
#'
#' @return
#' Returns as a vector the moving average for a time series.
#'
#' @param cases the time series of the newly observed cases per unit of time (ideally per day).
#' @param r_a The window size for the moving average that will be analyzed. If set to 1 the actual observations are analyzed. However, due to the variability of the reported cases between working days and weekends it is recommended that the 7-day moving average is analyzed (i.e. r_a = 7), which is the default for this argument. Users could prefer a longer interval of 14 days or one month (i.e., r_a=14 or 30, respectively).
#'
#' @examples
#' data("Italy")
#' mova(cases = Italy$Cases, r_a = 7)
#' mova(cases = Italy$Cases, r_a = 14)
#' @export
#' @references
#' Kostoulas, P., Meletis, E., Pateras, K. et al. The epidemic volatility index, a novel early warning tool for identifying new waves in an epidemic. Sci Rep 11, 23775 (2021). \doi{10.1038/s41598-021-02622-3}
#'
mova=function(cases, r_a=7){
ncases=rep(NA, length(cases))
for (i in 1:length(cases)){
ncases[i]=mean(cases[((i+1)-min(r_a,i)):i])
}
return(ncases)
}
#' Rolling standard deviation
#'
#' This function computes the rolling standard deviation for a time series.
#'
#' @return
#' Returns a vector with the estimated rolling standard deviation for a time series.
#'
#' @param cases the time series of the newly observed cases per unit of time (ideally per day).
#' @param lag_t integer - the size of the rolling window for which the rolling standard deviation is calculated (minimum/default value = 7, maximum recommended value = 30).
#'
#' @examples
#' data("Italy")
#' cases = mova(cases=Italy$Cases, r_a = 7)
#' roll = rollsd(cases=cases,lag_t = 7)
#'
#' @references
#' Kostoulas, P., Meletis, E., Pateras, K. et al. The epidemic volatility index, a novel early warning tool for identifying new waves in an epidemic. Sci Rep 11, 23775 (2021). \doi{10.1038/s41598-021-02622-3}
#'
#'
#' @export
rollsd = function(cases, lag_t=7) {
rollsd=rep(NA,length(cases))
for (i in 1:lag_t){
rollsd[i]=medvol(cases[1:i])
}
for (i in (lag_t+1):length(cases)){
rollsd[i]=medvol(cases[(i-(lag_t-1)):i])
}
return(rollsd)
}
#' True status definition
#'
#' This function defines the true status based on the case definition.
#'
#' @return
#' A vector of 0s and 1s is produced. Status = 1 is when the expected rise in the number of cases occurs and Status = 0 when the expected rise in the number of cases does not occur.
#'
#' @param cases the time series of the newly observed cases per unit of time (ideally per day).
#' @param r	 Definition for the minimum difference in the mean number of cases, one week before and after each time point that, if present, should be detected. This is the case definition and the default is 0.2 (with 0 <= r <= 1). A value of r=0.2 means that we have a case when the mean number of the newly observed cases in the next 7 days is at least 20% higher than the mean number of the newly observed cases in the past 7 days.
#'
#' @examples
#' data("Italy")
#' cases = mova(cases=Italy$Cases)
#' status = status(cases=cases, r=0.2)
#' @export
#'
#' @references
#' Kostoulas, P., Meletis, E., Pateras, K. et al. The epidemic volatility index, a novel early warning tool for identifying new waves in an epidemic. Sci Rep 11, 23775 (2021). \doi{10.1038/s41598-021-02622-3}
#'
#'
status = function(cases, r) {
ratio = 1/(1+r)
w_s=7
status=rep(NA,length(cases))
status[1]=NA
for (i in 2:(length(cases)-w_s)){
if (mean(cases[(i-min((i-1),w_s)):(i-1)])<=ratio*mean((cases[i:(i+min(i,(w_s-1)))]))) # deleted an equal sign
{status[i]=1}
else
{status[i]=0}
}
return(status)
}
# AFGHANISTAN
tmp_EVI_af=deviant(new_cases = Afghanistan[1:100],cum = TRUE)
ind2[i] <- 1}
if (!is.na(cevi[i]) && cevi[i] ==1 && (!is.na(cases[i]) & cases[i] > mean(cases[i:(i - min(7, i))]))){
ind2[i] <- 1
}else{ind2[i] <- 0}
if (mean(cases[(i-(w_s-1)):i])<=ratio*mean(cases[(i+1):(i+w_s)])){true_p[i]=1}
